function solution(targets) {
    var answer = 0;
    targets.sort((a,b) => a[1] - b[1]); //
    let norm = -1;
    
    for(const target of targets) {
        const [start, end] = target;
        if(start >= norm) {
            answer++;
            norm = end;
        }
    }
    
    return answer;
}

//0 - 그리디
//요격을 어디에할까에 초점을 두는 게 아니라, 정렬된 타겟을 거치며 ㄹㅇ 그리디로
//정렬 순서대로 타겟을 거치며, 처음 타겟의 끝을 norm으로 두고 그다음 타겟이 이전 타겟과 겹치는 부분이 없다면 요격++ 
//이전 기준과 겹치는 부분이 있다면 - 유지
//겹치는 부부닝 없다면 - 구분 - count++, 현재의 end를 norm으로

// 타겟을 end를 기준으로 정렬했어야 한다.
// 정렬 순서대로 거치며 값을 비교하기 때문에 정렬이 중요한데, 처음에 모든 구간을 다 차지해버리는 긴 타겟이 나오는 경우 값이 달라진다
// 0 4, 0 1, 2 3
// 결국 회의실과 마찬가지로 end가 중요한 로직임 - 더 많은 시간 확보 

//1 - 그리디
//모든 가능 좌표에서 요격 가능한 수를 구한다

//2 - 그리디인데, for문이 3개 필요.. 
//출발점 기준 정렬
//첫번째 타겟부터 타겟 범위 내 가장 많이 요격 가능한 곳 구함
//거길 요격해서 타겟들 삭제함 (visited로?)
//이제 다음, 삭제되지 않은 애의 범위 내 동일하게 
//4를 요격하면 [4,5]를 뚫는 것 (4,5) 되지만 (3,4)는 안됨 
